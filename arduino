/*******************************************************
 * ESP32-S3 FSR 센서 + BLE Notify + WiFi POST
 * (LED 상태 + JSON 포함, Render HTTPS 연동 + RTT 측정)
 *
 * - FSR 아날로그 값 읽기 (0~4095)
 * - BLE Notify로 안드로이드 앱에 센서값/LED 상태 전송
 * - WiFi(HTTPS)로 FastAPI 서버에 JSON POST
 * - POST 왕복시간(RTT) 시리얼에 출력
 *******************************************************/

#include <WiFi.h>
#include <WiFiClientSecure.h>   // HTTPS(SSL/TLS) 통신용
#include <HTTPClient.h>

#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>

// ======== WIFI SECTION ========
// ▶ 사용할 Wi-Fi AP 정보 (3개)

// AP1
const char* WIFI_SSID_1     = "U+Net97A4";
const char* WIFI_PASSWORD_1 = "5F8#4527HE";

// AP2
const char* WIFI_SSID_2     = "SMU";
const char* WIFI_PASSWORD_2 = "01081070192";

// AP3
const char* WIFI_SSID_3     = "0192";
const char* WIFI_PASSWORD_3 = "rcl0511";

// ▶ Render에 올린 FastAPI 서버 주소 (HTTPS 엔드포인트)
const char* SERVER_URL = "https://android-qdfu.onrender.com/sensor";

// ▶ HTTPS용 클라이언트 (전역으로 선언해서 재사용)
WiFiClientSecure secureClient;

// ======== BLE SECTION ========
// ▶ 앱과 통신할 BLE 서비스 / 캐릭터리스틱 UUID
#define SERVICE_UUID        "12345678-1234-1234-1234-1234567890ab"
#define CHARACTERISTIC_UUID "abcd1234-1234-5678-9999-abcdef123456"

// ▶ 센서값을 Notify로 쏴줄 캐릭터리스틱 포인터
BLECharacteristic* pCharacteristic = nullptr;

// ======== SENSOR SECTION ========
// ⚠ 실제로 FSR 센서를 연결한 ADC 핀 번호로 수정해야 함
//    예: GPIO4면 4, GPIO34면 34 (S3에서 ADC 가능한 핀 확인 필수)
const int SENSOR_PIN = 1;

// ▶ 임계값: 이 값보다 크면 LED 상태 1로 보고 서버에 전송
const int THRESHOLD  = 700;


// ======== WIFI 연결 함수 ========
// 3개의 AP를 순서대로 시도해서, 연결되면 바로 리턴
void connectWiFi() {
  const char* ssids[]  = { WIFI_SSID_1, WIFI_SSID_2, WIFI_SSID_3 };
  const char* passes[] = { WIFI_PASSWORD_1, WIFI_PASSWORD_2, WIFI_PASSWORD_3 };
  const int   apCount  = 3;

  for (int i = 0; i < apCount; i++) {
    Serial.println();
    Serial.print("📶 WiFi 연결 시도 (AP");
    Serial.print(i + 1);
    Serial.print("): ");
    Serial.println(ssids[i]);

    WiFi.begin(ssids[i], passes[i]);

    unsigned long start = millis();
    // 각 AP마다 최대 8초 정도 시도
    while (WiFi.status() != WL_CONNECTED && millis() - start < 8000) {
      delay(400);
      Serial.print(".");
    }

    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\n✅ WiFi 연결 완료!");
      Serial.print("연결된 SSID: ");
      Serial.println(ssids[i]);
      Serial.print("IP 주소: ");
      Serial.println(WiFi.localIP());

      // ⚠ 실습용: 서버 인증서 검증을 끄고 HTTPS 허용
      secureClient.setInsecure();
      return;
    }

    Serial.println("\n⚠ 이 AP 연결 실패 → 다음 AP 시도");
  }

  Serial.println("❌ 모든 AP 연결 실패 (WiFi 미연결 상태)");
}


// ======== 서버로 POST 보내는 함수 ========
// val  : FSR 센서 원시값 (0~4095)
// led  : LED 상태 (0 / 1)
void postToServer(int val, int led) {
  // 1) Wi-Fi 연결 상태 체크
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("⚠ WiFi 끊김 → 재연결 시도");
    connectWiFi();
  }

  // 그래도 안 붙었으면 포기
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("❌ WiFi 미연결 → POST 스킵");
    return;
  }

  HTTPClient http;

  // 2) HTTPS + 커스텀 WiFiClientSecure로 접속 준비
  if (!http.begin(secureClient, SERVER_URL)) {
    Serial.println("http.begin 실패 (URL 또는 클라이언트 문제)");
    return;
  }

  // 3) HTTP 헤더 설정 (JSON)
  http.addHeader("Content-Type", "application/json");

  // 4) 전송할 JSON 바디 구성
  //    예: {"device_id":"A-10","value":123,"led":1}
  String json = "{";
  json += "\"device_id\":\"A-10\",";         // 바리케이드/디바이스 ID
  json += "\"value\":" + String(val) + ",";  // 센서값
  json += "\"led\":"   + String(led);        // LED 상태
  json += "}";

  Serial.print("➡ 서버 POST: ");
  Serial.println(json);

  // 5) 여기서부터 RTT(왕복 지연시간) 측정
  unsigned long t0 = millis();        // POST 직전 시간
  int code = http.POST(json);         // 실제 HTTP POST 요청
  unsigned long t1 = millis();        // 응답 받은 직후 시간
  unsigned long rtt = t1 - t0;        // 왕복 시간(ms)

  // 6) 응답 코드 + RTT 출력
  Serial.print("⬅ 서버 응답 코드: ");
  Serial.print(code);
  Serial.print(" / ESP→서버 RTT: ");
  Serial.print(rtt);
  Serial.println(" ms");

  // 7) 연결 종료
  http.end();
}


// ======== SETUP ========
void setup() {
  Serial.begin(115200);
  delay(800);   // 시리얼 초기화 대기

  // 1) Wi-Fi 연결 시도 (3개 AP 순차 시도)
  connectWiFi();

  // 2) BLE 초기화
  BLEDevice::init("SmartFSR-A10");      // 앱에서 보이는 BLE 디바이스 이름
  BLEServer* pServer = BLEDevice::createServer();
  BLEService* pService = pServer->createService(SERVICE_UUID);

  // ▶ 센서값 + LED 상태를 전달할 캐릭터리스틱 생성 (읽기 + Notify)
  pCharacteristic = pService->createCharacteristic(
      CHARACTERISTIC_UUID,
      BLECharacteristic::PROPERTY_READ |
      BLECharacteristic::PROPERTY_NOTIFY
  );

  // ▶ Notify를 받기 위한 CCCD 디스크립터 추가
  pCharacteristic->addDescriptor(new BLE2902());

  // ▶ 서비스 시작 + 광고 시작
  pService->start();
  BLEDevice::startAdvertising();

  Serial.println("BLE Advertising 시작!");
}


// ======== LOOP ========
// ▶ 마지막으로 서버/앱으로 보낸 시각 저장 (ms)
unsigned long lastSend = 0;

void loop() {
  unsigned long now = millis();

  // ★ 1초마다 한 번씩 센서 읽고, BLE + 서버 전송
  if (now - lastSend >= 1000) {   // 1000ms = 1초
    lastSend = now;

    // 1) FSR 센서값 읽기 (0~4095)
    int val = analogRead(SENSOR_PIN);

    // 2) 임계값 기준 LED 상태 결정 (0 or 1)
    int ledState = (val > THRESHOLD) ? 1 : 0;

    // 3) 시리얼로 현재 상태 출력
    Serial.print("FSR 센서값: ");
    Serial.print(val);
    Serial.print(" / LED: ");
    Serial.println(ledState);

    // 4) BLE Notify로 앱에 센서값 전송
    //    포맷: "센서값 \t LED상태" (예: "1234\t1")
    String msg = String(val) + "\t" + String(ledState);
    if (pCharacteristic != nullptr) {
      pCharacteristic->setValue(msg.c_str());
      pCharacteristic->notify();
    }

    // 5) Wi-Fi + HTTPS로 서버에 JSON 전송 + RTT 측정
    postToServer(val, ledState);
  }

  // 외에는 특별한 작업 없음 → loop()가 빠르게 돌면서 타이밍만 체크
}
