/*******************************************************
 * Smart Barricade - ESP32-S3 (ë¹ ë¥¸ ë°˜ì‘ + WiFi AP ë²„ì „)
 * HX711 ë¡œë“œì…€(3ê°œ) + ë¦´ë ˆì´ ì œì–´ + BLE ì–‘ë°©í–¥ + WiFi AP
 *
 * (ìµœì¢… ìˆ˜ì •: actuatorStop() ì¬ì¶”ê°€ ë° setModeManual() ë¡œì§ ê°œì„ )
 *
 * - í˜„ì¬ëŠ” ë¡œë“œì…€ 1ë²ˆë§Œ ì‹¤ì œë¡œ ì—°ê²° (USE_LOADCELL2/3 = false)
 * - ë‚˜ì¤‘ì— 2, 3ë²ˆ ì—°ê²°í•˜ë©´ í”Œë˜ê·¸ë§Œ trueë¡œ ë°”ê¾¸ë©´ í™•ì¥ ê°€ëŠ¥
 *
 * ê¸°ëŠ¥ ìš”ì•½
 * - HX711 ë¡œë“œì…€ 3ê°œ êµ¬ì¡° (ì§€ê¸ˆì€ 1ë²ˆë§Œ ì‚¬ìš©)
 * - ìƒ˜í”Œ ì—¬ëŸ¬ ë²ˆ ì½ì–´ì„œ "ì´í•©"ì— ì¤‘ê°„ê°’ í•„í„° ì ìš©
 * - ì˜¤ë²„ì›¨ì´íŠ¸ ì¡°ê±´: ì‚¬ìš© ì¤‘ì¸ ë¡œë“œì…€ ì¤‘ í•˜ë‚˜ë¼ë„ THRESHOLD ì´ˆê³¼ â†’ EXTEND
 * - í•œ ë²ˆ ì˜¤ë²„ì›¨ì´íŠ¸ ë˜ë©´ ì´í›„ 10ì´ˆ ë™ì•ˆ ë¬´ì¡°ê±´ EXTEND ìœ ì§€
 * - BLE Notify:
 * "W,W1,W2,W3,overloaded,autoMode,actuatorState"
 * - WiFi AP + HTTP:
 * /status â†’ JSON í˜•ì‹ìœ¼ë¡œ W1/W2/W3 ë° over1/2/3, overloaded ë“± ì œê³µ
 * /cmd â†’ ëª¨ë“œ/ë™ì‘ ìˆ˜ë™ ì œì–´ (AUTO/MANUAL + EXTEND/RETRACT/STOP)
 *
 * - í†µì‹  ì •ì±…
 * âœ” BLE ì—°ê²°ë˜ë©´ â†’ WiFi AP ë” (BLE ìš°ì„ )
 * âœ” WiFi ìš”ì²­ ë“¤ì–´ì˜¤ë©´ â†’ BLE ê°•ì œ disconnect (WiFi ìš°ì„ )
 *******************************************************/

#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include "HX711.h"

// ===== WiFi / WebServer =====
#include <WiFi.h>
#include <WebServer.h>

// -----------------------------------------------------
// 0) WiFi AP ì„¤ì •
// -----------------------------------------------------
const char* AP_SSID = "SmartBarricade_AP";
const char* AP_PASS = "12345678";
WebServer server(80);

float g_lastW1 = 0.0f;
float g_lastW2 = 0.0f;
float g_lastW3 = 0.0f;
bool g_over1 = false;
bool g_over2 = false;
bool g_over3 = false;
bool g_overloaded = false;
bool g_autoModeHttp = true;
int g_actuatorState = 0; // 0: RETRACT (ë‹«í˜), 1: EXTEND (ì—´ë¦¼), -1: STOP (ì •ì§€)

// -----------------------------------------------------
// 1) HX711 & ë³´ì •ê°’ ì„¤ì •
// -----------------------------------------------------
const int LOADCELL1_DOUT_PIN = 12;
const int LOADCELL1_SCK_PIN  = 13;

const int LOADCELL2_DOUT_PIN = 4;
const int LOADCELL2_SCK_PIN  = 5;

const int LOADCELL3_DOUT_PIN = 16;
const int LOADCELL3_SCK_PIN  = 17;

HX711 scale1, scale2, scale3;

const float SET_SCALE1 = 8.686992f;
const float SET_SCALE2 = 8.686992f;
const float SET_SCALE3 = 8.686992f;

const bool USE_LOADCELL1 = true;
const bool USE_LOADCELL2 = false;
const bool USE_LOADCELL3 = false;

// -----------------------------------------------------
// 2) ë¦´ë ˆì´ í•€ ì„¤ì •
// -----------------------------------------------------
const int IN1 = 33;
const int IN2 = 26;
const int IN3 = 27;
const int IN4 = 14;

#define RELAY_ACTIVE_LOW 1
#if RELAY_ACTIVE_LOW
const int RELAY_ON  = LOW;
const int RELAY_OFF = HIGH;
#else
const int RELAY_ON  = HIGH;
const int RELAY_OFF = LOW;
#endif

// -----------------------------------------------------
// 3) ì•Œê³ ë¦¬ì¦˜ íŒŒë¼ë¯¸í„°
// -----------------------------------------------------
const float THRESHOLD = 10000.0f;
const int NUM_SAMPLES = 5;
const float ZERO_DEADZONE = 200.0f;

// -----------------------------------------------------
// 4) ìƒíƒœ ë³€ìˆ˜
// -----------------------------------------------------
int actuatorState = 0; // 0: RETRACT (ë‹«í˜), 1: EXTEND (ì—´ë¦¼), -1: STOP (ì •ì§€)
bool autoMode = true;
const unsigned long EXTEND_HOLD_MS = 10UL * 1000UL;
unsigned long extendHoldUntil = 0;

void startAP();
void actuatorStop();

// =====================================================
// ìœ í‹¸ í•¨ìˆ˜
// =====================================================
float medianFilter(float arr[], int n) {
    for (int i = 0; i < n - 1; i++)
        for (int j = i + 1; j < n; j++)
            if (arr[j] < arr[i]) {
                float t = arr[i];
                arr[i] = arr[j];
                arr[j] = t;
            }
    return arr[n / 2];
}

float applyDeadzone(float v) {
    if (v > -ZERO_DEADZONE && v < ZERO_DEADZONE) return 0.0f;
    return v;
}

void printRelayState(const char* label) {
    Serial.print(label);
    Serial.print(" IN1="); Serial.print(digitalRead(IN1));
    Serial.print(" IN2="); Serial.print(digitalRead(IN2));
    Serial.print(" IN3="); Serial.print(digitalRead(IN3));
    Serial.print(" IN4="); Serial.println(digitalRead(IN4));
}

void setModeAuto(const char* reason) {
    if (!autoMode) Serial.printf("### MODE -> AUTO (%s)\n", reason);
    autoMode = true;
    g_autoModeHttp = true;
    extendHoldUntil = 0;
}

// ìˆ˜ì •ëœ setModeManual: doStop=trueì¼ ë•Œ RETRACT ìƒíƒœë¡œ ì „í™˜
void setModeManual(const char* reason, bool doStop) {
    if (autoMode) Serial.printf("### MODE -> MANUAL (%s)\n", reason);
    autoMode = false;
    g_autoModeHttp = false;
    extendHoldUntil = 0;

    if (doStop) {
        // ê¸°ì¡´: STOP (ALL OFF)
        // ìˆ˜ì •: RETRACT (IN1, IN3 ON) ìƒíƒœë¡œ ì „í™˜í•˜ì—¬ ê¸°ë³¸ ìƒíƒœ ìœ ì§€
        actuatorStop(); // ì¼ë‹¨ ì •ì§€í•˜ì—¬ ëª¨í„° ì•ˆì „ ë³´ì¥
        
        digitalWrite(IN1, RELAY_ON);
        digitalWrite(IN3, RELAY_ON);

        actuatorState = 0; // RETRACT ìƒíƒœ
        g_actuatorState = 0;
        printRelayState("â–¶ Actuator: RETRACT (Manual Mode Start)");
    }
}

// =====================================================
// ë¦´ë ˆì´ ì œì–´ (actuatorStop() ì¬ì¶”ê°€)
// =====================================================

void actuatorStop() {
    if (actuatorState == -1) return; // ì´ë¯¸ ì •ì§€ ìƒíƒœë¼ë©´ ë¦¬í„´

    actuatorState = -1;
    g_actuatorState = -1;
    
    // ëª¨ë“  ë¦´ë ˆì´ë¥¼ OFFí•˜ì—¬ ëª¨í„° ì •ì§€
    digitalWrite(IN1, RELAY_OFF);
    digitalWrite(IN2, RELAY_OFF);
    digitalWrite(IN3, RELAY_OFF);
    digitalWrite(IN4, RELAY_OFF);

    printRelayState("â–¶ Actuator: STOP");
}


void actuatorRetract() {
    // ì´ë¯¸ RETRACT(0) ìƒíƒœë¼ë©´ ë¦¬í„´í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦´ë ˆì´ ë™ì‘ì„ ë§‰ìŒ
    if (actuatorState == 0) return; 
    
    actuatorStop(); // ë™ì‘ ì „ ë°˜ë“œì‹œ ì •ì§€

    actuatorState = 0;
    g_actuatorState = 0;

    // RETRACT (ë‹«í˜) ì‹œì‘
    digitalWrite(IN1, RELAY_ON);
    digitalWrite(IN3, RELAY_ON);

    printRelayState("â–¶ Actuator: close (1,3 ON)");
}

void actuatorExtend() {
    // ì´ë¯¸ EXTEND(1) ìƒíƒœë¼ë©´ ë¦¬í„´í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦´ë ˆì´ ë™ì‘ì„ ë§‰ìŒ
    if (actuatorState == 1) return;
    
    actuatorStop(); // ë™ì‘ ì „ ë°˜ë“œì‹œ ì •ì§€
    
    actuatorState = 1;
    g_actuatorState = 1;

    // EXTEND (ì—´ë¦¼) ì‹œì‘
    digitalWrite(IN2, RELAY_ON);
    digitalWrite(IN4, RELAY_ON);

    printRelayState("â–¶ Actuator: open (2,4 ON)");
}

// =====================================================
// BLE ê´€ë ¨
// =====================================================
#define SERVICE_UUID      "12345678-1234-1234-1234-1234567890ab"
#define CHAR_UUID_NOTIFY  "abcd1234-1234-5678-9999-abcdef123456"
#define CHAR_UUID_WRITE   "abcd0002-1234-5678-9999-abcdef123456"

BLEServer* pServer = nullptr;
BLECharacteristic* pNotifyChar = nullptr;
BLEAdvertising* pAdvertising = nullptr;

bool deviceConnected = false;
bool oldDeviceConnected = false;

class MyServerCallbacks : public BLEServerCallbacks {
    void onConnect(BLEServer*) override {
        deviceConnected = true;
        Serial.println("BLE Central ì—°ê²°ë¨");
        WiFi.softAPdisconnect(true);
    }
    void onDisconnect(BLEServer*) override {
        deviceConnected = false;
        Serial.println("BLE Central í•´ì œ â†’ AP ì¬ì‹œì‘");
        startAP();
    }
};

// ìˆ˜ì •: AUTO ëª¨ë“œì—ì„œ Action ëª…ë ¹ ì°¨ë‹¨ ë° STOP ëª…ë ¹ actuatorStop() ì‚¬ìš©
class CmdCallback : public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic* pChar) override {
        String cmd = String(pChar->getValue().c_str());
        cmd.trim(); cmd.toUpperCase();

        Serial.printf("BLE CMD: [%s]\n", cmd.c_str());

        if (cmd == "MODE_AUTO") setModeAuto("BLE");
        else if (cmd == "MODE_MANUAL") setModeManual("BLE", true);
        // MANUAL ëª¨ë“œì¼ ë•Œë§Œ ì•¡ì¶”ì—ì´í„° ì œì–´ í—ˆìš©
        else if (!autoMode && cmd == "EXTEND") { setModeManual("BLE EXTEND", false); actuatorExtend(); }
        else if (!autoMode && cmd == "RETRACT") { setModeManual("BLE RETRACT", false); actuatorRetract(); }
        else if (!autoMode && cmd == "STOP") { 
            setModeManual("BLE STOP", false); 
            actuatorStop(); // actuatorStop() í•¨ìˆ˜ ì‚¬ìš©
        }
        else if (autoMode && (cmd == "EXTEND" || cmd == "RETRACT" || cmd == "STOP")) {
            Serial.println("âŒ BLE CMD: AUTO ëª¨ë“œì—ì„œ ì•¡ì¶”ì—ì´í„° ì œì–´ ë¬´ì‹œë¨.");
        }
    }
};

void disconnectBleForWifi() {
    if (deviceConnected && pServer) {
        Serial.println("[HTTP] BLE Disconnect");
        pServer->disconnect(0);
    }
}

// =====================================================
// HTTP í•¸ë“¤ëŸ¬ (handleCmd ìˆ˜ì •ë¨: actuatorStop() ì‚¬ìš©)
// =====================================================
void handleStatus() {
    disconnectBleForWifi(); 
    String json = "{";
    json += "\"W1\":" + String(g_lastW1, 1) + ",";
    json += "\"W2\":" + String(g_lastW2, 1) + ",";
    json += "\"W3\":" + String(g_lastW3, 1) + ",";
    json += "\"over1\":" + String(g_over1) + ",";
    json += "\"over2\":" + String(g_over2) + ",";
    json += "\"over3\":" + String(g_over3) + ",";
    json += "\"overloaded\":" + String(g_overloaded) + ",";
    json += "\"autoMode\":" + String(g_autoModeHttp) + ",";
    json += "\"actuatorState\":" + String(g_actuatorState);
    json += "}";
    server.send(200, "application/json", json);
}

void handleCmd() {
    disconnectBleForWifi();

    String mode    = server.arg("mode");    mode.toUpperCase();
    String action = server.arg("action"); action.toUpperCase();

    // 1. ëª¨ë“œ ë³€ê²½ ì²˜ë¦¬ (mode ì¸ìê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰)
    if (mode == "AUTO") setModeAuto("HTTP /cmd");
    else if (mode == "MANUAL") setModeManual("HTTP /cmd", true);

    // 2. ì•¡ì¶”ì—ì´í„° ë™ì‘ ì²˜ë¦¬ (action ì¸ìê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰)
    if (action.length() > 0) {
        if (!autoMode) { // MANUAL ëª¨ë“œì¼ ë•Œë§Œ ì•¡ì¶”ì—ì´í„° ì œì–´ í—ˆìš©
            setModeManual("HTTP ACTION", false); // MANUAL ëª¨ë“œ ìœ ì§€ (doStop=false)
            if (action == "EXTEND") actuatorExtend();
            else if (action == "RETRACT") actuatorRetract();
            else if (action == "STOP") actuatorStop(); // actuatorStop() í•¨ìˆ˜ ì‚¬ìš©
        } else {
            Serial.println("âŒ HTTP CMD: AUTO ëª¨ë“œì—ì„œ ì•¡ì¶”ì—ì´í„° ì œì–´ ë¬´ì‹œë¨.");
        }
    }

    String json = "{";
    json += "\"ok\":1,";
    json += "\"mode\":\"" + String(autoMode ? "AUTO" : "MANUAL") + "\",";
    json += "\"action\":\"" + action + "\",";
    json += "\"actuatorState\":" + String(g_actuatorState);
    json += "}";

    server.send(200, "application/json", json);
}

void startWebServer() {
    server.on("/status", HTTP_ANY, handleStatus);
    server.on("/cmd",    HTTP_ANY, handleCmd);
    server.begin();
    Serial.println("ğŸŒ WebServer ì‹œì‘ (/status, /cmd)");
}

// =====================================================
// WiFi AP
// =====================================================
void startAP() {
    Serial.println("ğŸ“¡ AP ëª¨ë“œ ì‹œì‘â€¦");
    WiFi.mode(WIFI_AP);
    bool ok = WiFi.softAP(AP_SSID, AP_PASS);

    if (ok) {
        Serial.println("âœ… AP í™œì„±í™”ë¨");
        Serial.printf("SSID: %s\nPASS: %s\n", AP_SSID, AP_PASS);
        Serial.print("AP IP: "); Serial.println(WiFi.softAPIP());
    } else Serial.println("âŒ AP ì‹œì‘ ì‹¤íŒ¨");
}

// =====================================================
// SETUP
// =====================================================
void setup() {
    Serial.begin(115200);
    delay(1000);

    pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);
    pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);

    // ì´ˆê¸° ìƒíƒœ: RETRACT (IN1, IN3 ON) ìƒíƒœë¡œ ì‹œì‘ (ê¸°ë³¸ ìƒíƒœ)
    digitalWrite(IN2, RELAY_OFF);
    digitalWrite(IN4, RELAY_OFF);
    digitalWrite(IN1, RELAY_ON);
    digitalWrite(IN3, RELAY_ON);
    
    actuatorState = 0; // ì´ˆê¸° ìƒíƒœë¥¼ RETRACT(0)ë¡œ ì„¤ì •

    printRelayState("ì´ˆê¸° RETRACT (1,3 ON)");

    if (USE_LOADCELL1) { scale1.begin(LOADCELL1_DOUT_PIN, LOADCELL1_SCK_PIN); scale1.set_scale(SET_SCALE1); }
    if (USE_LOADCELL2) { scale2.begin(LOADCELL2_DOUT_PIN, LOADCELL2_SCK_PIN); scale2.set_scale(SET_SCALE2); }
    if (USE_LOADCELL3) { scale3.begin(LOADCELL3_DOUT_PIN, LOADCELL3_SCK_PIN); scale3.set_scale(SET_SCALE3); }

    Serial.println("Tare...");
    delay(500);
    if (USE_LOADCELL1) scale1.tare(10);
    if (USE_LOADCELL2) scale2.tare(10);
    if (USE_LOADCELL3) scale3.tare(10);

    // BLE ì´ˆê¸°í™”
    BLEDevice::init("SmartLoadcell-A10");
    pServer = BLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks());

    BLEService* pService = pServer->createService(SERVICE_UUID);

    pNotifyChar = pService->createCharacteristic(
        CHAR_UUID_NOTIFY,
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_NOTIFY
    );
    pNotifyChar->addDescriptor(new BLE2902()); // CCCD ë””ìŠ¤í¬ë¦½í„°

    BLECharacteristic* pWriteChar =
        pService->createCharacteristic(CHAR_UUID_WRITE, BLECharacteristic::PROPERTY_WRITE);
    pWriteChar->setCallbacks(new CmdCallback());

    pService->start();
    pAdvertising = BLEDevice::getAdvertising();
    pAdvertising->addServiceUUID(SERVICE_UUID);
    BLEDevice::startAdvertising();

    startAP();
    startWebServer();
}

// =====================================================
// LOOP
// =====================================================
void loop() {
    server.handleClient();

    float samples[NUM_SAMPLES];
    float lastW1 = 0, lastW2 = 0, lastW3 = 0;

    // 5ê°œì˜ ìƒ˜í”Œì„ ì½ì–´ì„œ ì¤‘ì•™ê°’ í•„í„°ë§ ì¤€ë¹„
    for (int i = 0; i < NUM_SAMPLES; i++) {
        float w1 = USE_LOADCELL1 ? scale1.get_units(1) : 0;
        float w2 = USE_LOADCELL2 ? scale2.get_units(1) : 0;
        float w3 = USE_LOADCELL3 ? scale3.get_units(1) : 0;

        lastW1 = w1; lastW2 = w2; lastW3 = w3;
        samples[i] = w1 + w2 + w3;
        delay(2);
    }

    float medTotal = applyDeadzone(medianFilter(samples, NUM_SAMPLES));
    lastW1 = applyDeadzone(lastW1);
    lastW2 = applyDeadzone(lastW2);
    lastW3 = applyDeadzone(lastW3);

    unsigned long nowMs = millis();

    bool over1 = USE_LOADCELL1 && (lastW1 > THRESHOLD);
    bool over2 = USE_LOADCELL2 && (lastW2 > THRESHOLD);
    bool over3 = USE_LOADCELL3 && (lastW3 > THRESHOLD);

    bool overNow = (over1 || over2 || over3);

    // ì „ì—­ ë³€ìˆ˜ ì—…ë°ì´íŠ¸ (HTTP /statusìš©)
    g_lastW1 = lastW1;
    g_lastW2 = lastW2;
    g_lastW3 = lastW3;
    g_over1 = over1;
    g_over2 = over2;
    g_over3 = over3;

    // ì˜¤ë²„ì›¨ì´íŠ¸ ë°œìƒ ì‹œ Hold time ì—…ë°ì´íŠ¸
    if (overNow) {
        unsigned long candidate = nowMs + EXTEND_HOLD_MS;
        if (candidate > extendHoldUntil) extendHoldUntil = candidate;
    }

    bool inExtendHoldWindow = (nowMs < extendHoldUntil);
    bool overloaded = overNow || inExtendHoldWindow;

    g_overloaded = overloaded;
    g_autoModeHttp = autoMode;

    // ì‹œë¦¬ì–¼ ëª¨ë‹ˆí„°ë§ ì¶œë ¥
    Serial.printf(
        "W1=%.1f | W2=%.1f | W3=%.1f | TOTAL=%.1f | over1=%c | over2=%c | over3=%c | hold=%s | mode=%s | actuator=%s\n",
        lastW1, lastW2, lastW3, medTotal,
        over1?'Y':'N', over2?'Y':'N', over3?'Y':'N',
        inExtendHoldWindow?"ON":"OFF",
        autoMode?"AUTO":"MANUAL",
        actuatorState==1?"EXTEND":(actuatorState==0?"RETRACT":"STOP")
    );

    // ìë™ ëª¨ë“œ ì œì–´ ë¡œì§
    if (autoMode) {
        if (overloaded) {
            if (actuatorState != 1) actuatorExtend();
        } else {
            if (actuatorState != 0) actuatorRetract();
        }
    }

    // BLE Notify ì „ì†¡
    if (deviceConnected && pNotifyChar) {
        char payload[64];
        // actuatorStateë¥¼ 0:RETRACT, 1:EXTEND, -1:STOPìœ¼ë¡œ ì‚¬ìš©í•˜ë¯€ë¡œ,
        // BLE ì „ì†¡ ì‹œì—ëŠ” 0:RETRACT, 1:EXTENDë§Œ ì‚¬ìš©í•œë‹¤ê³  ê°€ì •í•˜ê³  -1ì€ 0ìœ¼ë¡œ ì „ì†¡í•©ë‹ˆë‹¤.
        int bleActuatorState = (actuatorState == 1) ? 1 : 0; 
        
        snprintf(payload, sizeof(payload),
            "W,%.1f,%.1f,%.1f,%d,%d,%d\n", // W1, W2, W3, overloaded(1/0), autoMode(1/0), actuatorState(1/0)
            lastW1, lastW2, lastW3,
            overloaded ? 1 : 0,
            autoMode ? 1 : 0,
            bleActuatorState
        );
        pNotifyChar->setValue((uint8_t*)payload, strlen(payload));
        pNotifyChar->notify();
    }

    // BLE ì—°ê²° í•´ì œ í›„ ê´‘ê³  ì¬ì‹œì‘ ë¡œì§
    if (!deviceConnected && oldDeviceConnected) {
        delay(200);
        oldDeviceConnected = deviceConnected;
    }

    if (deviceConnected && !oldDeviceConnected) {
        oldDeviceConnected = deviceConnected;
    }

    delay(5);
}
