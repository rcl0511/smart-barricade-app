#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include "HX711.h"

// ===== WiFi / WebServer =====
#include <WiFi.h>
#include <WebServer.h>

// -----------------------------------------------------
// 0) WiFi AP ÏÑ§Ï†ï
// -----------------------------------------------------
const char* AP_SSID = "SmartBarricade_AP";
const char* AP_PASS = "12345678";
WebServer server(80);

float g_lastW1 = 0.0f;
float g_lastW2 = 0.0f;
float g_lastW3 = 0.0f;
bool g_over1 = false;
bool g_over2 = false;
bool g_over3 = false;
bool g_overloaded = false;
bool g_autoModeHttp = true;
// g_actuatorState: 0: RETRACT, 1: EXTEND, -1: STOP (Î™®Îëê OFF), -2: MANUAL_IN_CONTROL (Í∞úÎ≥Ñ ON)
int g_actuatorState = 0;

// 1) HX711 & Î≥¥Ï†ïÍ∞í ÏÑ§Ï†ï
const int LOADCELL1_DOUT_PIN = 12;
const int LOADCELL1_SCK_PIN = 13;
const int LOADCELL2_DOUT_PIN = 4;
const int LOADCELL2_SCK_PIN = 5;
const int LOADCELL3_DOUT_PIN = 16;
const int LOADCELL3_SCK_PIN = 17;

HX711 scale1, scale2, scale3;

const float SET_SCALE1 = 9.425f;
const float SET_SCALE2 = 9.4f;
const float SET_SCALE3 = 10.6f;

const bool USE_LOADCELL1 = true;
const bool USE_LOADCELL2 = true;
const bool USE_LOADCELL3 = true;

// 2) Î¶¥Î†àÏù¥ ÌïÄ ÏÑ§Ï†ï
const int IN1 = 33;
const int IN2 = 26;
const int IN3 = 27;
const int IN4 = 14;

#define RELAY_ACTIVE_LOW 1
#if RELAY_ACTIVE_LOW
const int RELAY_ON = LOW;
const int RELAY_OFF = HIGH;
#else
const int RELAY_ON = HIGH;
const int RELAY_OFF = LOW;
#endif

const float THRESHOLD = 10000.0f;
const int NUM_SAMPLES = 5;
const float ZERO_DEADZONE = 200.0f;

// -----------------------------------------------------
// 4) ÏÉÅÌÉú Î≥ÄÏàò
// -----------------------------------------------------
// actuatorState: 0: RETRACT, 1: EXTEND, -1: STOP (Î™®Îëê OFF), -2: MANUAL_IN_CONTROL (Í∞úÎ≥Ñ ON)
int actuatorState = 0;
bool autoMode = true;
const unsigned long EXTEND_HOLD_MS = 10UL * 1000UL;
unsigned long extendHoldUntil = 0;

void startAP();
void actuatorStop();
void actuatorRetract();
void actuatorExtend();

// =====================================================
// Ïú†Ìã∏ Ìï®Ïàò
// =====================================================
float medianFilter(float arr[], int n) {
  for (int i = 0; i < n - 1; i++)
    for (int j = i + 1; j < n; j++)
      if (arr[j] < arr[i]) {
        float t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
      }
  return arr[n / 2];
}

float applyDeadzone(float v) {
  if (v > -ZERO_DEADZONE && v < ZERO_DEADZONE) return 0.0f;
  return v;
}

void printRelayState(const char* label) {
  Serial.print(label);
  Serial.print(" IN1=");
  Serial.print(digitalRead(IN1));
  Serial.print(" IN2=");
  Serial.print(digitalRead(IN2));
  Serial.print(" IN3=");
  Serial.print(digitalRead(IN3));
  Serial.print(" IN4=");
  Serial.println(digitalRead(IN4));
}

void setModeAuto(const char* reason) {
  if (!autoMode) Serial.printf("### MODE -> AUTO (%s)\n", reason);
  autoMode = true;
  g_autoModeHttp = true;
  extendHoldUntil = 0;
}

// setModeManual: doStop=trueÏùº Îïå RETRACT ÏÉÅÌÉúÎ°ú Ï†ÑÌôò (Ï¥àÍ∏∞ ÏÑ§Ï†ï Ïú†ÏßÄ)
void setModeManual(const char* reason, bool doStop) {
  if (autoMode) Serial.printf("### MODE -> MANUAL (%s)\n", reason);
  autoMode = false;
  g_autoModeHttp = false;
  extendHoldUntil = 0;

  if (doStop) {
    // Í∏∞Ï°¥ RETRACT ÏÉÅÌÉúÎ°ú Ï†ÑÌôòÌïòÏó¨ Í∏∞Î≥∏ ÏÉÅÌÉú Ïú†ÏßÄ
    actuatorStop();
    delay(10);

    // Î¶¥Î†àÏù¥ 1, 3ÏùÑ ONÌïòÏó¨ RETRACT ÏÉÅÌÉúÎ•º Î™ÖÏãúÏ†ÅÏúºÎ°ú Ïú†ÏßÄ (setup()Í≥º ÎèôÏùº)
    digitalWrite(IN1, RELAY_ON);
    digitalWrite(IN3, RELAY_ON);

    actuatorState = 0;  // RETRACT ÏÉÅÌÉú
    g_actuatorState = 0;
    printRelayState("-> Actuator: RETRACT (Manual Mode Start)");
  }
}

// =====================================================
// Î¶¥Î†àÏù¥ Ï†úÏñ¥ (Í∏∞Ï°¥ Î≥µÌï© Ï†úÏñ¥ Ïú†ÏßÄ)
// =====================================================

void actuatorStop() {
  // üí° ÏàòÏ†ï: actuatorStateÍ∞Ä Ïù¥ÎØ∏ -1 (STOP)Ïù¥ ÏïÑÎãàÎùºÎ©¥ Ïã§Ìñâ
  if (actuatorState != -1) {
    actuatorState = -1;
    g_actuatorState = -1;

    // Î™®Îì† Î¶¥Î†àÏù¥Î•º OFFÌïòÏó¨ Î™®ÌÑ∞ Ï†ïÏßÄ
    digitalWrite(IN1, RELAY_OFF);
    digitalWrite(IN2, RELAY_OFF);
    digitalWrite(IN3, RELAY_OFF);
    digitalWrite(IN4, RELAY_OFF);

    printRelayState("-> Actuator: STOP");
  }
}

void actuatorRetract() {
  // Ïù¥ÎØ∏ RETRACT(0) ÏÉÅÌÉúÎùºÎ©¥ Î¶¨ÌÑ¥ÌïòÏó¨ Î∂àÌïÑÏöîÌïú Î¶¥Î†àÏù¥ ÎèôÏûëÏùÑ ÎßâÏùå
  if (actuatorState == 0) return;

  actuatorStop();  // ÎèôÏûë Ï†Ñ Î∞òÎìúÏãú Ï†ïÏßÄ (actuatorStateÎäî -1Ïù¥ Îê®)

  // üõë Î¶¥Î†àÏù¥Ïùò Í∏∞Í≥ÑÏ†Å Ï†ëÏ†ê ÏïàÏ†ïÌôî ÏãúÍ∞Ñ (10ms) Ï∂îÍ∞Ä
  delay(10);

  actuatorState = 0;
  g_actuatorState = 0;

  // RETRACT (Îã´Ìûò) ÏãúÏûë (IN1, IN3 ON)
  digitalWrite(IN1, RELAY_ON);
  digitalWrite(IN3, RELAY_ON);

  printRelayState("-> Actuator: close (1,3 ON)");
}

void actuatorExtend() {
  // Ïù¥ÎØ∏ EXTEND(1) ÏÉÅÌÉúÎùºÎ©¥ Î¶¨ÌÑ¥ÌïòÏó¨ Î∂àÌïÑÏöîÌïú Î¶¥Î†àÏù¥ ÎèôÏûëÏùÑ ÎßâÏùå
  if (actuatorState == 1) return;

  actuatorStop();  // ÎèôÏûë Ï†Ñ Î∞òÎìúÏãú Ï†ïÏßÄ (actuatorStateÎäî -1Ïù¥ Îê®)

  // üõë Î¶¥Î†àÏù¥Ïùò Í∏∞Í≥ÑÏ†Å Ï†ëÏ†ê ÏïàÏ†ïÌôî ÏãúÍ∞Ñ (10ms) Ï∂îÍ∞Ä
  delay(10);

  actuatorState = 1;
  g_actuatorState = 1;

  // EXTEND (Ïó¥Î¶º) ÏãúÏûë (IN2, IN4 ON)
  digitalWrite(IN2, RELAY_ON);
  digitalWrite(IN4, RELAY_ON);

  printRelayState("-> Actuator: open (2,4 ON)");
}

// =====================================================
// üìå Í∞úÎ≥Ñ Ï†úÏñ¥ Î™ÖÎ†π Ìï®Ïàò (INx_ON)
// =====================================================

// 1. IN1 ON (Actuator Retract)
void actuatorIn1On() {
  actuatorStop();  // ÏïàÏ†ÑÏùÑ ÏúÑÌï¥ Ï†ÑÏ≤¥ Ï†ïÏßÄ (Î™®Îëê OFF, actuatorState = -1)
  delay(10);
  digitalWrite(IN1, RELAY_ON);  // IN1Îßå ON
  digitalWrite(IN2, RELAY_OFF);
  digitalWrite(IN3, RELAY_OFF);
  digitalWrite(IN4, RELAY_OFF);

  // üí° Ï§ëÏöî: ÏÉÅÌÉúÎ•º -2Î°ú Î≥ÄÍ≤ΩÌïòÏó¨ Îã§Ïùå Stop Î™ÖÎ†πÏù¥ Îì§Ïñ¥Ïò¨ Ïàò ÏûàÎèÑÎ°ù Ï§ÄÎπÑ
  actuatorState = -2;
  g_actuatorState = -2;

  Serial.println("-> IN1 ON: Actuator Retract");
  printRelayState("-> IN1 ON");
}

// 2. IN2 ON (Actuator Extend)
void actuatorIn2On() {
  actuatorStop();
  delay(10);
  digitalWrite(IN1, RELAY_OFF);
  digitalWrite(IN2, RELAY_ON);  // IN2Îßå ON
  digitalWrite(IN3, RELAY_OFF);
  digitalWrite(IN4, RELAY_OFF);

  actuatorState = -2;
  g_actuatorState = -2;

  Serial.println("-> IN2 ON: Actuator Extend");
  printRelayState("-> IN2 ON");
}

// 3. IN3 ON (LED Close)
void actuatorIn3On() {
  actuatorStop();
  delay(10);
  digitalWrite(IN1, RELAY_OFF);
  digitalWrite(IN2, RELAY_OFF);
  digitalWrite(IN3, RELAY_ON);  // IN3Îßå ON
  digitalWrite(IN4, RELAY_OFF);

  actuatorState = -2;
  g_actuatorState = -2;

  Serial.println("-> IN3 ON: LED Retract/Close");
  printRelayState("-> IN3 ON");
}

// 4. IN4 ON (LED Open)
void actuatorIn4On() {
  actuatorStop();
  delay(10);
  digitalWrite(IN1, RELAY_OFF);
  digitalWrite(IN2, RELAY_OFF);
  digitalWrite(IN3, RELAY_OFF);
  digitalWrite(IN4, RELAY_ON);  // IN4Îßå ON

  actuatorState = -2;
  g_actuatorState = -2;

  Serial.println("-> IN4 ON: LED Extend/Open");
  printRelayState("-> IN4 ON");
}

// 5. Loadcell Tare (Offset Ï¥àÍ∏∞Ìôî)
void tareAllLoadcells() {
  Serial.println("-> Loadcell Tare (Offset Reset) ÏãúÏûë...");
  delay(500);
  if (USE_LOADCELL1 && scale1.is_ready()) scale1.tare(10);
  if (USE_LOADCELL2 && scale2.is_ready()) scale2.tare(10);
  if (USE_LOADCELL3 && scale3.is_ready()) scale3.tare(10);
  Serial.println("-> Loadcell Tare ÏôÑÎ£å (Unready ÏÑºÏÑúÎäî Í±¥ÎÑàÎúÄ)");
}

// =====================================================
// BLE Í¥ÄÎ†®
// =====================================================
#define SERVICE_UUID "12345678-1234-1234-1234-1234567890ab"
#define CHAR_UUID_NOTIFY "abcd1234-1234-5678-9999-abcdef123456"
#define CHAR_UUID_WRITE "abcd0002-1234-5678-9999-abcdef123456"

BLEServer* pServer = nullptr;
BLECharacteristic* pNotifyChar = nullptr;
BLEAdvertising* pAdvertising = nullptr;

bool deviceConnected = false;
bool oldDeviceConnected = false;

class MyServerCallbacks : public BLEServerCallbacks {
  void onConnect(BLEServer*) override {
    deviceConnected = true;
    Serial.println("BLE Central Ïó∞Í≤∞Îê®");
    WiFi.softAPdisconnect(true);
  }
  void onDisconnect(BLEServer*) override {
    deviceConnected = false;
    Serial.println("BLE Central Ìï¥Ï†ú -> AP Ïû¨ÏãúÏûë");
    startAP();
  }
};

// CmdCallback: BLE Î™ÖÎ†π Ï≤òÎ¶¨ (INTx Î∞è INx_ON Î™®Îëê Ï≤òÎ¶¨)
class CmdCallback : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic* pChar) override {
    String cmd = String(pChar->getValue().c_str());
    cmd.trim();
    cmd.toUpperCase();

    Serial.printf("BLE CMD: [%s]\n", cmd.c_str());

    if (cmd == "MODE_AUTO") setModeAuto("BLE");
    else if (cmd == "MODE_MANUAL") setModeManual("BLE", true);

    // TAREÎäî Î™®ÎìúÏôÄ Í¥ÄÍ≥ÑÏóÜÏù¥ ÌóàÏö© (is_ready() ÏÉÅÌÉúÏù∏ ÏÑºÏÑúÎßå Tare)
    else if (cmd == "TARE") tareAllLoadcells();

    // Î¶¥Î†àÏù¥ Î∞è Ïï°Ï∂îÏóêÏù¥ÌÑ∞ Ï†úÏñ¥Îäî MANUAL Î™®ÎìúÏùº ÎïåÎßå ÌóàÏö©
    else if (!autoMode) {
      setModeManual("BLE ACTION", false);  // MANUAL Î™®Îìú Ïú†ÏßÄ

      // Í∏∞Ï°¥ Î≥µÌï© Ïï°Ï∂îÏóêÏù¥ÌÑ∞ Ï†úÏñ¥
      if (cmd == "EXTEND") actuatorExtend();
      else if (cmd == "RETRACT") actuatorRetract();
      else if (cmd == "STOP") actuatorStop();

      // üî• INT Î™ÖÎ†π Ï≤òÎ¶¨ Ï∂îÍ∞Ä (Ïï±Ïù¥ INTxÎ•º Î≥¥ÎÇº Í≤ΩÏö∞)
      else if (cmd == "INT1") actuatorIn1On();
      else if (cmd == "INT2") actuatorIn2On();
      else if (cmd == "INT3") actuatorIn3On();
      else if (cmd == "INT4") actuatorIn4On();
      // -----------------------------------------------------

      // üìå INx_ON Î™ÖÎ†π Ï≤òÎ¶¨ Î°úÏßÅ (Ïï±Ïù¥ INx_ONÏùÑ Î≥¥ÎÇº Í≤ΩÏö∞)
      else if (cmd == "IN1_ON") actuatorIn1On();
      else if (cmd == "IN2_ON") actuatorIn2On();
      else if (cmd == "IN3_ON") actuatorIn3On();
      else if (cmd == "IN4_ON") actuatorIn4On();
    } else if (autoMode && (cmd == "EXTEND" || cmd == "RETRACT" || cmd == "STOP" || cmd == "IN1_ON" || cmd == "IN2_ON" || cmd == "IN3_ON" || cmd == "IN4_ON" || cmd == "INT1" || cmd == "INT2" || cmd == "INT3" || cmd == "INT4")) {
      Serial.println("-> BLE CMD: AUTO Î™®ÎìúÏóêÏÑú Ïï°Ï∂îÏóêÏù¥ÌÑ∞/Î¶¥Î†àÏù¥ Ï†úÏñ¥ Î¨¥ÏãúÎê®.");
    }
  }
};

void disconnectBleForWifi() {
  if (deviceConnected && pServer) {
    Serial.println("[HTTP] BLE Disconnect");
    pServer->disconnect(0);
  }
}

// =====================================================
// HTTP Ìï∏Îì§Îü¨ (INTx Î∞è INx_ON Î™®Îëê Ï≤òÎ¶¨)
// =====================================================
void handleStatus() {
  disconnectBleForWifi();
  String json = "{";
  json += "\"W1\":" + String(g_lastW1, 1) + ",";
  json += "\"W2\":" + String(g_lastW2, 1) + ",";
  json += "\"W3\":" + String(g_lastW3, 1) + ",";
  json += "\"over1\":" + String(g_over1) + ",";
  json += "\"over2\":" + String(g_over2) + ",";
  json += "\"over3\":" + String(g_over3) + ",";
  json += "\"overloaded\":" + String(g_overloaded) + ",";
  json += "\"autoMode\":" + String(g_autoModeHttp) + ",";
  json += "\"actuatorState\":" + String(g_actuatorState);
  json += "}";
  server.send(200, "application/json", json);
}

void handleCmd() {
  disconnectBleForWifi();

  String mode = server.arg("mode");
  mode.toUpperCase();
  String action = server.arg("action");
  action.toUpperCase();

  // 1. Î™®Îìú Î≥ÄÍ≤Ω Ï≤òÎ¶¨ (mode Ïù∏ÏûêÍ∞Ä ÏûàÏùÑ ÎïåÎßå Ïã§Ìñâ)
  if (mode == "AUTO") setModeAuto("HTTP /cmd");
  else if (mode == "MANUAL") setModeManual("HTTP /cmd", true);

  // 2. Ïï°Ï∂îÏóêÏù¥ÌÑ∞ Î∞è Í∏∞ÌÉÄ ÎèôÏûë Ï≤òÎ¶¨ (action Ïù∏ÏûêÍ∞Ä ÏûàÏùÑ ÎïåÎßå Ïã§Ìñâ)
  if (action.length() > 0) {
    // TAREÎäî Î™®ÎìúÏôÄ Í¥ÄÍ≥ÑÏóÜÏù¥ ÌóàÏö©
    if (action == "TARE") {
      tareAllLoadcells();
    }
    // Î¶¥Î†àÏù¥ Î∞è Ïï°Ï∂îÏóêÏù¥ÌÑ∞ Ï†úÏñ¥Îäî MANUAL Î™®ÎìúÏùº ÎïåÎßå ÌóàÏö©
    else if (!autoMode) {
      setModeManual("HTTP ACTION", false);  // MANUAL Î™®Îìú Ïú†ÏßÄ (doStop=false)

      // Í∏∞Ï°¥ Î≥µÌï© Ïï°Ï∂îÏóêÏù¥ÌÑ∞ Ï†úÏñ¥
      if (action == "EXTEND") actuatorExtend();
      else if (action == "RETRACT") actuatorRetract();
      else if (action == "STOP") actuatorStop();

      // üî• INT Î™ÖÎ†π Ï≤òÎ¶¨ Ï∂îÍ∞Ä (Ïï±Ïù¥ INTxÎ•º Î≥¥ÎÇº Í≤ΩÏö∞)
      else if (action == "INT1") actuatorIn1On();
      else if (action == "INT2") actuatorIn2On();
      else if (action == "INT3") actuatorIn3On();
      else if (action == "INT4") actuatorIn4On();
      // -----------------------------------------------------

      // üìå INx_ON Î™ÖÎ†π Ï≤òÎ¶¨ Î°úÏßÅ (Ïï±Ïù¥ INx_ONÏùÑ Î≥¥ÎÇº Í≤ΩÏö∞)
      else if (action == "IN1_ON") actuatorIn1On();
      else if (action == "IN2_ON") actuatorIn2On();
      else if (action == "IN3_ON") actuatorIn3On();
      else if (action == "IN4_ON") actuatorIn4On();
    } else {
      Serial.println("-> HTTP CMD: AUTO Î™®ÎìúÏóêÏÑú Ïï°Ï∂îÏóêÏù¥ÌÑ∞/Î¶¥Î†àÏù¥ Ï†úÏñ¥ Î¨¥ÏãúÎê®.");
    }
  }

  String json = "{";
  json += "\"ok\":1,";
  json += "\"mode\":\"" + String(autoMode ? "AUTO" : "MANUAL") + "\",";
  json += "\"action\":\"" + action + "\",";
  json += "\"actuatorState\":" + String(g_actuatorState);
  json += "}";

  server.send(200, "application/json", json);
}

void startWebServer() {
  server.on("/status", HTTP_ANY, handleStatus);
  server.on("/cmd", HTTP_ANY, handleCmd);
  server.begin();
  Serial.println("-> WebServer ÏãúÏûë (/status, /cmd)");
}

// =====================================================
// WiFi AP
// =====================================================
void startAP() {
  Serial.println("-> AP Î™®Îìú ÏãúÏûë...");
  WiFi.mode(WIFI_AP);
  bool ok = WiFi.softAP(AP_SSID, AP_PASS);

  if (ok) {
    Serial.println("-> AP ÌôúÏÑ±ÌôîÎê®");
    Serial.printf("SSID: %s\nPASS: %s\n", AP_SSID, AP_PASS);
    Serial.print("AP IP: ");
    Serial.println(WiFi.softAPIP());
  } else Serial.println("-> AP ÏãúÏûë Ïã§Ìå®");
}

// =====================================================
// SETUP
// =====================================================
void setup() {
  Serial.begin(115200);
  delay(1000);

  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);

  // Ï¥àÍ∏∞ ÏÉÅÌÉú: RETRACT (IN1, IN3 ON) ÏÉÅÌÉúÎ°ú ÏãúÏûë
  digitalWrite(IN2, RELAY_OFF);
  digitalWrite(IN4, RELAY_OFF);
  digitalWrite(IN1, RELAY_ON);
  digitalWrite(IN3, RELAY_ON);

  actuatorState = 0;  // Ï¥àÍ∏∞ ÏÉÅÌÉúÎ•º RETRACT(0)Î°ú ÏÑ§Ï†ï

  printRelayState("Ï¥àÍ∏∞ RETRACT (1,3 ON)");

  if (USE_LOADCELL1) {
    scale1.begin(LOADCELL1_DOUT_PIN, LOADCELL1_SCK_PIN);
    scale1.set_scale(SET_SCALE1);
  }
  if (USE_LOADCELL2) {
    scale2.begin(LOADCELL2_DOUT_PIN, LOADCELL2_SCK_PIN);
    scale2.set_scale(SET_SCALE2);
  }
  if (USE_LOADCELL3) {
    scale3.begin(LOADCELL3_DOUT_PIN, LOADCELL3_SCK_PIN);
    scale3.set_scale(SET_SCALE3);
  }

  // üí° Î°úÎìúÏÖÄ ÏïàÏ†ïÌôîÎ•º ÏúÑÌïú ÏßÄÏó∞ ÏãúÍ∞Ñ Ï∂îÍ∞Ä (ÌïÑÏöîÏãú)
  Serial.println("Waiting for HX711s to stabilize...");
  delay(1000);

  Serial.println("Tare...");
  delay(500);
  if (USE_LOADCELL1 && scale1.is_ready()) scale1.tare(10);
  if (USE_LOADCELL2 && scale2.is_ready()) scale2.tare(10);
  if (USE_LOADCELL3 && scale3.is_ready()) scale3.tare(10);
  Serial.println("-> Ï¥àÍ∏∞ Tare ÏôÑÎ£å (Unready ÏÑºÏÑúÎäî Í±¥ÎÑàÎúÄ)");

  // BLE Ï¥àÍ∏∞Ìôî
  BLEDevice::init("SmartLoadcell-A10");
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());

  BLEService* pService = pServer->createService(SERVICE_UUID);

  pNotifyChar = pService->createCharacteristic(
    CHAR_UUID_NOTIFY,
    BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_NOTIFY);
  pNotifyChar->addDescriptor(new BLE2902());  // CCCD ÎîîÏä§ÌÅ¨Î¶ΩÌÑ∞

  BLECharacteristic* pWriteChar =
    pService->createCharacteristic(CHAR_UUID_WRITE, BLECharacteristic::PROPERTY_WRITE);
  pWriteChar->setCallbacks(new CmdCallback());

  pService->start();
  pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  BLEDevice::startAdvertising();

  startAP();
  startWebServer();
}

// =====================================================
// LOOP
// =====================================================
void loop() {

  server.handleClient();

  float samples[NUM_SAMPLES];
  float lastW1 = 0, lastW2 = 0, lastW3 = 0;

  // ÎîîÎ≤ÑÍπÖÏùÑ ÏúÑÌï¥ Raw ValueÎ•º Ï†ÄÏû•Ìï† Î≥ÄÏàò Ï∂îÍ∞Ä
  long raw1 = 0, raw2 = 0, raw3 = 0;

  static unsigned long lastLogMs = 0;
  static unsigned long lastReadyCheckMs = 0;

  unsigned long nowMs = millis();
  bool ready1 = USE_LOADCELL1 ? scale1.is_ready() : true;
  bool ready2 = USE_LOADCELL2 ? scale2.is_ready() : true;
  bool ready3 = USE_LOADCELL3 ? scale3.is_ready() : true;


  // üö® Î°úÎìúÏÖÄ Ï§ÄÎπÑ ÏÉÅÌÉú ÌôïÏù∏ Î∞è Í≤ΩÍ≥† Ï∂úÎ†• (1Ï¥àÎßàÎã§)
  if (nowMs - lastReadyCheckMs >= 1000) {
    lastReadyCheckMs = nowMs;
    if (USE_LOADCELL1 && !ready1) Serial.println("!!! WARNING: LOADCELL1 is not ready. Treating as 0.");
    if (USE_LOADCELL2 && !ready2) Serial.println("!!! WARNING: LOADCELL2 is not ready. Treating as 0.");
    if (USE_LOADCELL3 && !ready3) Serial.println("!!! WARNING: LOADCELL3 is not ready. Treating as 0.");
  }

  // 5Í∞úÏùò ÏÉòÌîåÏùÑ ÏùΩÏñ¥ÏÑú Ï§ëÏïôÍ∞í ÌïÑÌÑ∞ÎßÅ Ï§ÄÎπÑ
  for (int i = 0; i < NUM_SAMPLES; i++) {

    // ÏÑºÏÑúÍ∞Ä Ï§ÄÎπÑÎêòÏóàÏùÑ ÎïåÎßå Í∞íÏùÑ ÏùΩÍ≥†, ÏïÑÎãàÎ©¥ 0ÏúºÎ°ú Ï≤òÎ¶¨
    if (USE_LOADCELL1 && ready1) {
      lastW1 = scale1.get_units(1);
      raw1 = scale1.get_value(1);
    } else {
      lastW1 = 0;
      raw1 = 0;
    }

    if (USE_LOADCELL2 && ready2) {
      lastW2 = scale2.get_units(1);
      raw2 = scale2.get_value(1);
    } else {
      lastW2 = 0;
      raw2 = 0;
    }

    if (USE_LOADCELL3 && ready3) {
      lastW3 = scale3.get_units(1);
      raw3 = scale3.get_value(1);
    } else {
      lastW3 = 0;
      raw3 = 0;
    }

    samples[i] = lastW1 + lastW2 + lastW3;
    delay(2);
  }

  float medTotal = applyDeadzone(medianFilter(samples, NUM_SAMPLES));
  lastW1 = applyDeadzone(lastW1);
  lastW2 = applyDeadzone(lastW2);
  lastW3 = applyDeadzone(lastW3);

  bool over1 = USE_LOADCELL1 && (lastW1 > THRESHOLD);
  bool over2 = USE_LOADCELL2 && (lastW2 > THRESHOLD);
  bool over3 = USE_LOADCELL3 && (lastW3 > THRESHOLD);

  bool overNow = (over1 || over2 || over3);

  // Ï†ÑÏó≠ Î≥ÄÏàò ÏóÖÎç∞Ïù¥Ìä∏ (HTTP /statusÏö©)
  g_lastW1 = lastW1;
  g_lastW2 = lastW2;
  g_lastW3 = lastW3;
  g_over1 = over1;
  g_over2 = over2;
  g_over3 = over3;

  // Ïò§Î≤ÑÏõ®Ïù¥Ìä∏ Î∞úÏÉù Ïãú Hold time ÏóÖÎç∞Ïù¥Ìä∏
  if (overNow) {
    unsigned long candidate = nowMs + EXTEND_HOLD_MS;
    if (candidate > extendHoldUntil) extendHoldUntil = candidate;
  }

  bool inExtendHoldWindow = (nowMs < extendHoldUntil);
  bool overloaded = overNow || inExtendHoldWindow;

  g_overloaded = overloaded;
  g_autoModeHttp = autoMode;

  // ÏãúÎ¶¨Ïñº Î™®ÎãàÌÑ∞ÎßÅ Ï∂úÎ†•
  if (nowMs - lastLogMs >= 1000) {  // 300ms = 0.3Ï¥à
    lastLogMs = nowMs;

    Serial.printf(
      "W1=%.1f (Raw:%ld, Rdy:%c) | W2=%.1f (Raw:%ld, Rdy:%c) | W3=%.1f (Raw:%ld, Rdy:%c) | TOTAL=%.1f\n",
      lastW1, raw1, ready1 ? 'Y' : 'N', lastW2, raw2, ready2 ? 'Y' : 'N', lastW3, raw3, ready3 ? 'Y' : 'N', medTotal);
    Serial.printf(
      "O1=%c | O2=%c | O3=%c | hold=%s | mode=%s | actuator=%s\n",
      over1 ? 'Y' : 'N', over2 ? 'Y' : 'N', over3 ? 'Y' : 'N',
      inExtendHoldWindow ? "ON" : "OFF",
      autoMode ? "AUTO" : "MANUAL",
      actuatorState == 1 ? "EXTEND" : (actuatorState == 0 ? "RETRACT" : (actuatorState == -1 ? "STOP" : "MANUAL_ACT"))
    );
  }

  // ÏûêÎèô Î™®Îìú Ï†úÏñ¥ Î°úÏßÅ (ÏàòÎèô Í∞úÎ≥Ñ Ï†úÏñ¥ Ï§ë(-2)Ïù¥ ÏïÑÎãê ÎïåÎßå Ïã§Ìñâ)
  if (autoMode && actuatorState != -2) { // üî• -2 ÏÉÅÌÉú Í∞ÑÏÑ≠ Î∞©ÏßÄ Î°úÏßÅ Ï∂îÍ∞Ä
    if (overloaded) {
      if (actuatorState != 1) actuatorExtend();
    } else {
      if (actuatorState != 0) actuatorRetract();
    }
  } else if (!autoMode && actuatorState == -2) { // MANUAL Î™®ÎìúÏóêÏÑú Í∞úÎ≥Ñ ÏàòÎèô Ï†úÏñ¥ Ï§ëÏùº Îïå
      // ÏïÑÎ¨¥Í≤ÉÎèÑ ÌïòÏßÄ ÏïäÏùå (Î¶¥Î†àÏù¥ ÏÉÅÌÉúÎ•º Ïú†ÏßÄ)
  }

  // BLE Notify Ï†ÑÏÜ°
  if (deviceConnected && pNotifyChar) {
    char payload[64];
    // BLEÏóêÎäî 0 ÎòêÎäî 1 ÏÉÅÌÉúÎßå Ï†ÑÏÜ° (ÏàòÎèô Í∞úÎ≥Ñ Ï†úÏñ¥ ÏÉÅÌÉúÎäî 0ÏúºÎ°ú Í∞ÑÏ£º)
    int bleActuatorState = (actuatorState == 1) ? 1 : 0;

    snprintf(payload, sizeof(payload),
             "W,%.1f,%.1f,%.1f,%d,%d,%d\n",  // W1, W2, W3, overloaded(1/0), autoMode(1/0), actuatorState(1/0)
             lastW1, lastW2, lastW3,
             overloaded ? 1 : 0,
             autoMode ? 1 : 0,
             bleActuatorState);
    pNotifyChar->setValue((uint8_t*)payload, strlen(payload));
    pNotifyChar->notify();
  }

  // BLE Ïó∞Í≤∞ Ìï¥Ï†ú ÌõÑ Í¥ëÍ≥† Ïû¨ÏãúÏûë Î°úÏßÅ
  if (!deviceConnected && oldDeviceConnected) {
    delay(200);
    oldDeviceConnected = deviceConnected;
  }

  if (deviceConnected && !oldDeviceConnected) {
    oldDeviceConnected = deviceConnected;
  }

  delay(5);
}
